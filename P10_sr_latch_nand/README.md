# Project 10 - Simulate SR-Latch (NAND) + Metastability (VHDL/ISim)

## Цель
Смоделировать и просимулировать SR-Latch на NAND-элементах (S/R активны по нулю) и увидеть,
как из-за обратной связи и задержек могут появляться неустойчивые/метастабильные режимы.
Digilent отдельно отмечает, что такие схемы - это combinational loops, и в FPGA обычно считаются плохой практикой,
если поведение не контролируется. :contentReference[oaicite:4]{index=4}

## SR-Latch NAND (S_n, R_n active-low)
Таблица (NAND):
- `S_n=1, R_n=1` - **hold** (хранение)
- `S_n=0, R_n=1` - **SET** (`Q=1, Qb=0`)
- `S_n=1, R_n=0` - **RESET** (`Q=0, Qb=1`)
- `S_n=0, R_n=0` - **запрещено** (`Q=1, Qb=1`)

## Что симулируем (ключевой момент)
В testbench вводим запрещённое состояние `S_n=R_n=0`, а в **600 ns** одновременно отпускаем оба входа `0→1`
(переход в hold). Digilent указывает, что такой переход может запустить астабильность/метастабильность. :contentReference[oaicite:5]{index=5}

## Как запускать (ISE/ISim)
1) Добавь `sr_latch_nand.vhd` и `tb_P10_Simulate_SR_Latch.vhd` в проект.
2) В Simulation Sources выбери top = `tb_P10_Simulate_SR_Latch`.
3) Запусти **Simulate Behavioral Model**.
4) На waveform добавь: `S_n`, `R_n`, `Q_bal`, `Qb_bal`, `Q_bias`, `Qb_bias`.

## Как искать "неустойчивость" на waveform
- Найди область около **600 ns** (там одновременно меняются `S_n` и `R_n`).
- Сделай Zoom In.
- В "balanced" варианте (`Q_bal/Qb_bal`) возможны:
  - серия быстрых переключений,
  - длительное неопределённое поведение,
  - "дребезг" перед выбором состояния (зависит от симулятора и задержек).
- В "biased" варианте (`Q_bias/Qb_bias`) симметрия нарушена, и latch обычно выбирает одно устойчивое состояние быстрее.

⚠️ Если на waveform ты видишь `1000 ps` вместо 0/1 - ты добавил не сигналы, а параметры времени (generics/constants).
Нужны именно логические сигналы `Q*`, `S_n`, `R_n`.

## Нужно ли UCF и .bit?
Для этого проекта - **нет**, это учебная симуляция поведения latch и метастабильности.
На плате LED всё равно не покажет наносекундные эффекты, а combinational loops в FPGA требуют особой осторожности.
