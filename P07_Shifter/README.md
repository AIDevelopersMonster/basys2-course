# Project 7 - Barrel Shifter (комбинаторный сдвиг) 4-bit | Basys2 | VHDL

## Цель
Сделать **комбинаторный barrel shifter**: сдвиг 4-битного слова на 0..3 разряда
за один проход комбинационной логики (без такта и без регистров).

Это **не** "shift register":
- Barrel shifter - комбинаторика (сразу реагирует на входы)
- Shift register - последовательностная логика (нужен CLK, часто RESET/LOAD)

---

## Теория
Сдвиг:
- влево: биты уходят к старшим, освобождаются младшие
- вправо: биты уходят к младшим, освобождаются старшие

В проект добавлен параметр **FILL** - чем заполнять освобождающиеся биты.
- FILL=0 → логический сдвиг с заполнением нулями
- FILL=1 → заполнение единицами (удобно для демонстрации)
(Аналог "арифметического" сдвига вправо - это когда FILL = sign bit, но тут FILL задаём вручную.)

---

## Подключение на Basys2

### Входы (SW)
- SW(3..0) = A(3..0)   данные
- SW(5..4) = SH(1..0)  величина сдвига 0..3
- SW(6)    = DIR       0=влево, 1=вправо
- SW(7)    = FILL      бит заполнения

### Выходы (LED)
- LED(3..0) = Y(3..0)  результат сдвига
- LED(7..4) = A(3..0)  исходное значение (для сравнения)

---

## Реализация (VHDL)
Сделано поведенчески:
- `if dir then ... else ...`
- внутри `case sh` для 0..3

Значения по умолчанию задаются в начале процесса, чтобы не синтезировались latch.

---

## Симуляция (ISim) и testbench
`tb_P07_Shifter.vhd` делает полный перебор 256 векторов:
- A: 0..15
- SH: 0..3
- DIR: 0/1
- FILL: 0/1

Проверка через `assert`. В конце:
`TB PASSED: all 256 vectors OK.`

---

## Сборка в Xilinx ISE
1. Добавить `P07_Shifter.vhd` в Implementation (Top Module).
2. Добавить UCF с пинами SW/LED.
3. Synthesize → Implement → Generate Programming File.
4. Прошить Basys2 через Adept/JTAG.

---
## Проверка на плате (после прошивки)

1) **Прошейте FPGA** и убедитесь, что прошивка реально загрузилась:
- после программирования через Adept/JTAG плата должна продолжать работать **сразу**, без перезагрузки ПК;
- если ничего не меняется при переключении SW, проверьте, что прошивали именно **FPGA**, а не ROM, и что выбран правильный `.bit`.

2) **Проверка логики сдвига "вживую"**
- `LED(7..4)` показывают исходное значение `A(3..0)` (то, что выставлено на `SW(3..0)`).
- `LED(3..0)` показывают результат `Y(3..0)`.

Это удобно: вы всегда видите **вход и выход одновременно** и можете быстро понять, корректен ли сдвиг.

3) **Что крутить на переключателях**
- Выставьте данные: `SW(3..0) = A`.
- Выберите величину сдвига: `SW(5..4) = SH`:
  - `00` → без сдвига
  - `01` → сдвиг на 1
  - `10` → сдвиг на 2
  - `11` → сдвиг на 3
- Выберите направление: `SW(6) = DIR`:
  - `0` → сдвиг влево
  - `1` → сдвиг вправо
- Выберите заполнитель: `SW(7) = FILL`:
  - `0` → заполняем нулями
  - `1` → заполняем единицами

4) **Быстрые тесты (рекомендуется)**
- Поставьте `A = 1010`, `FILL=0`:
  - DIR=0, SH=01 → `0100`
  - DIR=1, SH=01 → `0101`
- Поставьте `A = 1000`, `DIR=1`, `SH=11`, `FILL=1` → результат должен стать `1111`
  (потому что при сдвиге вправо освобождаются старшие биты и заполняются единицами)

Если вход `A` на `LED(7..4)` меняется, а `Y` на `LED(3..0)` нет - значит проблема не в логике, а в прошивке/пинах (UCF) или выбран не тот top-модуль.

### Примеры проверки "байт на SW → байт на LED"

В этом проекте удобно проверять всё **байтом**:

- `SW[7:0] = FILL DIR SH1 SH0 A3 A2 A1 A0`
- `LED[7:0] = A3 A2 A1 A0 Y3 Y2 Y1 Y0` (потому что `LED = A & Y`, где `LED(7..4)=A`, `LED(3..0)=Y`)

Ниже несколько быстрых тестов (в шестнадцатеричном виде):

- **SW = 0x1A** (`0b0_0_01_1010`) → сдвиг **влево на 1**, `FILL=0`  
  Ожидаем: `Y=0100` → **LED = 0xA4** (`1010_0100`)

- **SW = 0x5A** (`0b0_1_01_1010`) → сдвиг **вправо на 1**, `FILL=0`  
  Ожидаем: `Y=0101` → **LED = 0xA5** (`1010_0101`)

- **SW = 0xF8** (`0b1_1_11_1000`) → сдвиг **вправо на 3**, `FILL=1`  
  Ожидаем: `Y=1111` → **LED = 0x8F** (`1000_1111`)

- **SW = 0xA3** (`0b1_0_10_0011`) → сдвиг **влево на 2**, `FILL=1`  
  Ожидаем: `Y=1111` → **LED = 0x3F** (`0011_1111`)


---
## Файлы
- P07_Shifter.vhd - top (синтезируемый)
- tb_P07_Shifter.vhd - testbench
- *.ucf - ограничения под Basys2 (SW/LED)
