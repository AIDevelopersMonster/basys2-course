# Project 5 — Decoder 3→8 (one-hot) + Enable на Basys2 (VHDL)

## Цель
Реализовать **дешифратор 3→8**: по трёхбитному коду `A(2..0)` активировать ровно один выход `Y(i)=1`
(формат one-hot). Добавить сигнал разрешения `EN`.

---

## Теория
Дешифратор 3→8 преобразует код `A` в one-hot вектор длиной 8:

- при `EN=0` все выходы 0
- при `EN=1` активен ровно один выход, номер которого равен `A`

Пример:
- `A=000` → `Y=00000001`
- `A=011` → `Y=00001000`
- `A=111` → `Y=10000000`

Это базовый узел, который используется для:
- выбора одного из устройств/каналов,
- адресации,
- построения таблиц истинности и PLA/ROM-логики.

---

## Подключение на Basys2

### Входы (SW)
- `SW(2..0)` → `A(2..0)` (адрес 0..7)
- `SW(3)` → `EN` (разрешение)

### Выходы (LED)
- `LED(7..0)` → `Y(7..0)` (one-hot)

---

## Реализация (VHDL)
Сделано поведенчески:
- `y <= (others => '0')` как значение по умолчанию (важно, чтобы не синтезировалась защёлка),
- при `EN=1` выбираем один из 8 вариантов в `case`.

---

## Симуляция (ISim)
Файл `tb_P05_Decoder.vhd`:
- инициализирует `SW` нулями (чтобы не было `U/X`),
- перебирает `EN ∈ {0,1}` и `A ∈ {0..7}`,
- сравнивает `LED` с эталоном через `assert`.

Ожидаемое сообщение в конце:
`TB PASSED: all vectors OK.`

---

## Сборка в Xilinx ISE (кратко)
1. Добавить `P05_Decoder.vhd` в Implementation (Top Module).
2. Добавить UCF с пинами SW/LED (можно общий шаблон Basys2).
3. Synthesize → Implement → Generate Programming File.
4. Прошить плату через Adept/JTAG.

---

## Файлы
- `P05_Decoder.vhd` — top (синтез)
- `tb_P05_Decoder.vhd` — testbench
- `.ucf` — ограничения под Basys2 (SW/LED)
