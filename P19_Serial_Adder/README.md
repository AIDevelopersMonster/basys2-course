# P19 - Serial Adder (последовательный сумматор)

Проект **P19** демонстрирует **последовательное (bit‑serial) сложение** двух 4‑битных чисел на плате **Digilent Basys 2 (Spartan‑3E)**.

В отличие от параллельного сумматора, где все разряды складываются одновременно, в serial‑adder вычисление выполняется **по одному биту за шаг**:

1. Берём младшие биты `A0` и `B0` и текущий перенос `carry`.
2. Полный сумматор (full adder) выдаёт бит суммы `S0` и новый перенос `carry_next`.
3. `S0` записывается в результат в позицию текущего индекса `bit_idx`.
4. Регистры `A` и `B` сдвигаются вправо, `carry := carry_next`, `bit_idx++`.
5. Через `N=4` шага получаем `SUM[3:0]` и `COUT`.

---

## Файлы

- `P19_Serial_Adder.vhd` - верхний модуль проекта (под плату)
- `P19_Serial_Adder_tb.vhd` - тестбенч (быстрая симуляция за счёт укороченного debounce)

---

## Подключение к Basys 2 (переключатели/кнопки/светодиоды)

### Ввод

- `SW(3 downto 0)` → число **A[3:0]**
- `SW(7 downto 4)` → число **B[3:0]**

### Управление

- `BTN3` → **LOAD/RESET** (загрузить A,B и сбросить состояние вычисления)
- `BTN0` → **STEP** (выполнить один шаг сложения; в коде есть программная блокировка дребезга)

### Вывод

- `LED(3 downto 0)` → **SUM[3:0]**
- `LED4` → **COUT** (перенос после завершения; горит только когда `done=1`)
- `LED(7 downto 5)` → **bit_idx** (на каком разряде сейчас находимся: 0..3)

---

## Как повторить на плате (пошаговый режим)

### Быстрый алгоритм
1. Выставьте на тумблерах значение **A** (`SW3..SW0`) и **B** (`SW7..SW4`).
2. Нажмите `BTN3` (**LOAD/RESET**) - регистры A,B загрузятся, `SUM` и `COUT` обнулятся, шаг станет `0`.
3. Нажимайте `BTN0` (**STEP**) **ровно 4 раза** (по числу разрядов). После каждого нажатия считается один разряд и обновляются светодиоды.

> Подсказка: `LED7..LED5` - это номер текущего шага/разряда `bit_idx` (0…3).  
> `LED3..LED0` - накапливаемая сумма `SUM[3:0]`.  
> `LED4` (`COUT`) загорается **только после завершения** (после 4‑го шага).

### Пример «по шагам» (A=6, B=5)

**Что ставим на тумблерах:**
- `A = 6` → двоично `0110` → поставить `SW3..SW0 = 0 1 1 0`
- `B = 5` → двоично `0101` → поставить `SW7..SW4 = 0 1 0 1`

Ожидаем: `6 + 5 = 11` → `SUM = 1011`, `COUT = 0`.

1) Нажимаем **BTN3 (LOAD/RESET)**  
- `LED7..LED5 = 000` (шаг 0)  
- `LED3..LED0 = 0000` (сумма ещё не считалась)  
- `LED4 = 0`

Далее нажимаем **BTN0 (STEP)**:

| Нажатие STEP | Какой бит считаем | LED7..LED5 (bit_idx после шага) | LED3..LED0 (SUM) | LED4 (COUT) |
|---:|---:|:---:|:---:|:---:|
| 1 | бит 0 (LSB) | 001 | 0001 | 0 | 						00100001
| 2 | бит 1 | 010 | 0011 | 0 | 								00100011
| 3 | бит 2 | 011 | 0011 *(бит2=0, перенос=1)* | 0 | 	01100011
| 4 | бит 3 (MSB) | 011 *(done=1)* | 1011 | 0 | 		01101011

**Что вы увидите в конце (после 4-го STEP):**
- `LED3..LED0 = 1011` (11 десятичное)
- `LED4 = 0` (переноса нет)

### Пример с переносом (A=9, B=7)

Если хотите увидеть перенос:
- `A=9 (1001)`, `B=7 (0111)` → `9+7=16` → `SUM=0000`, `COUT=1`.  
После 4‑го шага `LED4` загорится, а `LED3..LED0` будут `0000`.

---

## Теория: полный сумматор (1 разряд)

Для одного разряда используются стандартные формулы полного сумматора:

- `S = A XOR B XOR Cin`
- `Cout = (A AND B) OR (A AND Cin) OR (B AND Cin)`

В последовательном сумматоре `Cin` - это сохранённый перенос `carry` от предыдущего шага.

---

## Про debounce (дребезг кнопок)

Кнопки на реальной плате дают дребезг, поэтому в модуле есть блокировка повторного нажатия:

- Параметр `G_DEBOUNCE_CYCLES` задаёт число тактов игнорирования после нажатия `STEP`.
- По умолчанию: `1_000_000` тактов ≈ 20 мс при 50 МГц.
- В тестбенче этот параметр уменьшается (`G_DEBOUNCE_CYCLES => 10`), чтобы симуляция шла быстро.

---

## Симуляция (Testbench)

`P19_Serial_Adder_tb.vhd`:

- Инициализирует все входы (без `U/X` на старте).
- Моделирует нажатия `BTN3` и четыре нажатия `BTN0`.
- Сравнивает `SUM` и `COUT` с эталоном через `assert` для нескольких наборов данных.

Ожидаемый финал симуляции: сообщение `All testcases passed.` без `severity error`.

---

## Примечание по ISE

Не забудьте проверить настройку **FPGA Start‑Up Clock → JTAG Clock** (если прошиваете напрямую через Adept/JTAG), как в вашем шаблоне репозитория.