# Project 6 — Priority Encoder 8→3 + Valid (VHDL, Basys2)

## Цель
Сделать **приоритетный шифратор 8→3**:
- вход `X(7..0)` (8 линий),
- выход `Y(2..0)` — номер **самого старшего** установленного бита,
- сигнал `V` (valid) — признак наличия хотя бы одной единицы на входе.

---

## Теория
Обычный encoder 8→3 предполагает, что активна **ровно одна** входная линия.
В реальности часто бывает несколько `1` одновременно — тогда нужен **priority encoder**:

- если `X7=1`, то `Y=7` независимо от остальных;
- иначе если `X6=1`, то `Y=6`;
- ...
- иначе если `X0=1`, то `Y=0`;
- если `X=0`, то `V=0`.

---

## Подключение на Basys2

### Входы (SW)
- `SW(7..0)` → `X(7..0)`

### Выходы (LED)
- `LED(2..0)` → `Y(2..0)`
- `LED(3)` → `V`
- `LED(7..4)` → 0

---

## Реализация (VHDL)
Сделано через цепочку `if/elsif` от старшего бита к младшему:
- так явно задаётся приоритет,
- синтезатор оптимизирует логику автоматически,
- чтобы не синтезировалась защёлка, задаём значения по умолчанию для `Y` и `V`.

---

## Симуляция (ISim) и testbench
`tb_P06_PriorityEncoder.vhd` выполняет полный перебор 256 комбинаций `X`:
- проверяет `V = 1`, если `X != 0`,
- проверяет `Y` как индекс старшего установленного бита.

Ожидаемое сообщение:
`TB PASSED: all 256 vectors OK.`

---

## Сборка в Xilinx ISE (кратко)
1. Добавить `P06_PriorityEncoder.vhd` в Implementation (Top Module).
2. Добавить UCF с пинами SW/LED.
3. Synthesize → Implement → Generate Programming File.
4. Прошить Basys2 через Adept/JTAG.

---

## Файлы
- `P06_PriorityEncoder.vhd` — top (синтез)
- `tb_P06_PriorityEncoder.vhd` — testbench
- `.ucf` — ограничения SW/LED
