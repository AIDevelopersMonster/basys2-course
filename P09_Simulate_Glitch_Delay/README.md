# Project 9 - Simulate Glitch and Delay (VHDL/ISim)

## Цель
Показать, как **задержки распространения** в комбинационной схеме могут вызвать **glitch (hazard)** даже там, где булева функция должна оставаться постоянной.
Digilent предлагает явно задать задержку каждого "элемента" в симуляторе и увидеть, как поведение схемы меняется из-за delay.  
Также цель - понять причину glitch и способ убрать static glitch добавлением лишнего логического терма.  

## Схема
Реализуется:
- `N1 = A & B`
- `N2 = ~B`
- `N3 = N2 & C`
- `X  = N1 | N3`

Проблема: от входа `B` к выходу `X` есть два пути с разными суммарными задержками (unbalanced path), поэтому при фиксированных `A` и `C` и переключении `B` на выходе может появиться кратковременный провал.  

## Исправление static-1 hazard
Добавляем редундантный (консенсусный) терм:
- `N4 = A & C`
- `X = (A&B) | (~B&C) | (A&C)`

При `A=C=1` терм `A&C` постоянно 1 и не даёт выходу кратковременно упасть.

## Как запустить в ISE/ISim
1. Добавь `P09_Simulate_Glitch_Delay.vhd` в проект.
2. Добавь `tb_P09_Simulate_Glitch_Delay.vhd` в Simulation Sources.
3. Сделай testbench top и запусти **Simulate Behavioral Model**.
4. Открой waveform и смотри сигналы `A,B,C,X_haz,X_fix`.

Ожидание (как у Digilent): glitch появляется при `A=1`, `C=1` и переключении `B` (особенно на переходе `1→0`), и длится порядка 1 нс при задержках 1 нс на каждом элементе.  
В консоли ISim будет `Measured glitch width ...` и `TB PASSED...`.

## Эксперименты (как в Digilent)
- Поставь задержку OR больше (например 2 ns) и посмотри, как изменится момент/длительность.
- Поставь все задержки по 5 ns и сравни результат.
Это удобно делать через generics `T_*` в `P09_Simulate_Glitch_Delay`.

## Как найти glitch (hazard) на waveform в ISim и понять, откуда он берётся

### 1) Что именно смотреть
В waveform добавь сигналы:
- входы: `A`, `B`, `C`
- выходы: `X_haz` (с глитчем), `X_fix` (исправленный)
- внутренние узлы (если они выведены в архитектуре как `signal`): `N1`, `N2`, `N3` (и опционально `N4`)

Смысл узлов:
- `N1 = A & B`
- `N2 = not B`
- `N3 = N2 & C`
- `X_haz = N1 or N3` (без исправления)
- `X_fix = N1 or N3 or N4`, где `N4 = A & C` (исправление static-1 hazard)

### 2) Где glitch появляется в этом проекте (самый наглядный кейс)
Glitch легче всего увидеть при:
- `A = 1`
- `C = 1`
- и переключении `B` (особенно на переходе `1 → 0`)

Логически функция должна оставаться `X = 1`, но из-за задержек путей выход `X_haz` может кратковременно провалиться в `0`.

### 3) Как "поймать" glitch на временной диаграмме
1. Запусти симуляцию и найди на waveform участок, где `A=1` и `C=1`.
2. Найди момент переключения `B` (фронт или спад).
3. Увеличь масштаб по времени (Zoom In), пока не увидишь детали на уровне наносекунд.
4. Смотри на `X_haz`:
   - glitch выглядит как короткий "зубчик" (кратковременный импульс 0 или 1),
   - чаще всего это очень узкий провал/всплеск между двумя стабильными участками.

> Если используешь задержки через `transport`, короткие импульсы не "съедаются" и видны на waveform.

### 4) Как понять, почему он возник (разбор по внутренним узлам)
Сравни моменты переключений `N1` и `N3` относительно изменения `B`:

- При `A=C=1` и переходе `B: 1 → 0`:
  - `N1 = A&B` падает после своей задержки (`T_AND1`)
  - `N2 = not B` поднимается после `T_NOT`
  - `N3 = N2&C` поднимается ещё позже: после `T_NOT + T_AND2`

Если в промежутке времени **и `N1=0`, и `N3=0`**, то на OR-элементе получается **`X_haz=0`** - это и есть glitch.
На waveform это обычно выглядит так:
- `N1` уже сменился,
- `N3` ещё не сменился,
- и только потом `N3` догоняет - `X_haz` возвращается в 1.

### 5) Что должно быть в исправленной версии
Смотри `X_fix`:
- при тех же условиях (`A=C=1`, `B` переключается) **`X_fix` не должен проваливаться**.
Причина: добавленный терм `N4 = A&C` держит OR "в единице", закрывая окно, когда `N1` и `N3` одновременно нули.

### 6) Полезный приём: измерить ширину glitch
На waveform можно измерить длительность "зубчика":
- поставь курсоры на момент падения `X_haz` и момент возврата в 1,
- разница по времени ≈ ширина glitch.
Она зависит от разницы суммарных задержек путей (unbalanced path).

Если хочешь усилить эффект, увеличь значения `T_*` (например, до 5 ns) - glitch станет "шире" и визуально заметнее.

