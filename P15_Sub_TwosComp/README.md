# P15 - Вычитание через дополнительный код (Two's Complement)

Проект **P15** демонстрирует реализацию вычитания **A − B** на FPGA
**Digilent Basys 2 (Spartan-3E)** с использованием **дополнительного кода (two's complement)**.

В отличие от проекта **P14**, где отрицательный результат определялся через сигнал *Borrow*,
в данном проекте отрицательные числа **кодируются непосредственно в битах результата**.
Именно такой подход используется в **ALU и процессорах**.

---

## Цель проекта

* Понять принцип дополнительного кода
* Научиться выполнять вычитание через сложение
* Показать, что **один сумматор** может выполнять и ADD, и SUB
* Связать теорию двоичных чисел с реальной FPGA-реализацией

---

## Теория

Дополнительный код числа `B` формируется по правилу:

```
−B = ¬B + 1
```

Тогда вычитание сводится к сложению:

```
A − B = A + (¬B + 1)
```

Таким образом:

* отдельный вычитатель не нужен
* используется **обычный двоичный сумматор**
* знак результата хранится в старшем бите

---

## Аппаратная конфигурация (Basys 2)

На плате Basys 2 все 8 ползунков расположены **в один ряд** и образуют байт.
В проекте принято следующее соглашение, основанное на физическом расположении:

```
SW7 SW6 SW5 SW4  SW3 SW2 SW1 SW0
 └─── B ───┘    └─── A ───┘
```

* `SW7-SW4` - число **B**
* `SW3-SW0` - число **A**

---

## Индикация

| Светодиоды | Назначение                      |
| ---------- | ------------------------------- |
| `LED[3:0]` | Результат в дополнительном коде |
| `LED[7]`   | Знак результата (MSB)           |
| `LED[6]`   | Carry out (для анализа)         |
| `LED[5:4]` | Не используются                 |

---

## Практическая часть: работа на плате

### ▶️ Задание 1: A > B (положительный результат)

Установите ползунки:

```
SW = 0011 0101
```

Интерпретация:

```
B = 3
A = 5
```

Результат:

```
A − B = 2
LED[3:0] = 0010
LED[7] = 0
```

---

### ▶️ Задание 2: A < B (отрицательный результат)

```
SW = 0101 0011
```

```
B = 5
A = 3
```

Результат на плате:

```
LED[3:0] = 1110
LED[7] = 1
```

Интерпретация:

```
1110₂ = −2 (two's complement)
```

В отличие от P14:

* **Borrow не требуется**
* знак уже закодирован в результате

---

### ▶️ Задание 3: A = 0, B = 1

```
SW = 0001 0000
```

Результат:

```
LED[3:0] = 1111
LED[7] = 1
```

```
1111₂ = −1
```

---

### ▶️ Задание 4: Нулевой случай

```
SW = 0000 0000
```

```
LED[3:0] = 0000
LED[7] = 0
```

---

## Что важно понять

* Дополнительный код позволяет **избавиться от отдельного вычитателя**
* Отрицательное число хранится прямо в битах
* Старший бит - это **знак**, а не ошибка
* Именно так работают ALU и процессоры

---

## Связь с другими проектами

* **P13** - Двоичный сумматор
* **P14** - Вычитатель с Borrow
* **P15** - Вычитание через two's complement
* **P16** - ALU (ADD / SUB одним сумматором)

---

## Инструменты

* FPGA: Digilent Basys 2 (Spartan-3E XC3S100E)
* Язык: VHDL
* Среда: Xilinx ISE WebPACK

---

## Назначение проекта

Проект предназначен для **учебных целей** и может свободно использоваться
в курсах по цифровой схемотехнике и FPGA-разработке.
